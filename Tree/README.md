# 非线性结构--树

​        树结构包含树和二叉树，树和二叉树属于非线性结构。在树的结构中，每个结点只允许有一个直接前驱结点，但允许有一个以上直接后继结点。树的存储结构和操作实现都比较复杂，但树可以转换为二叉树进行处理。大多数二叉树的操作实现需要用递归方法。

【主要内容】

- 树的基本概念和存储结构
- 二叉树的基本概念、性质、操作实现及遍历
- 线索二叉树的概念和设计方法
- 哈夫曼树的概念和设计方法及其应用
- 树和二叉树的转换方法

【学习目标】

- 树的概念、存储方法、基本运算
- 链式存储结构在表达非线性数据结构中的作用



## 1.  树的逻辑结构

### 1.1  树的定义

**树（Tree）**是由n（n>=0）个结点构成的有限集合，其中n=0的树称为空树；n=1的树只有一个结点；n>1的树T由如下特点：

- 有一个特殊的结点称为根结点（Root），根节点没有前驱结点；

- 除根结点外，其余结点被分为m（m>0）个互不相交的集合
  $$
  T_1，T_2，...,T_m
  $$
  其中每个集合
  $$
  T_i(1<=i<=m)
  $$
  本身又是一颗结构与树类同的子树。

  树是递归结构--在数的定义中用到了树的定义本身：一颗非空树是若干棵子树构成的，而子树又可由若干棵更小的子树构成。

**结点：** 结点包含一个数据元素及若干指向其子树的分支信息。

**结点的度：** 结点所有拥有的子树的个数称为该结点的度。

**叶子结点：** 每个结点有零个或多个结点，没有子节点（度为0）的结点称为叶子结点，叶子结点也称为终端结点。

**分支结点：** 度不为0的结点称为分支结点，分支结点也称为非终端结点，一个树中除叶子结点外的所有结点都是分支结点。

**孩子（Child）结点：** 树中一个结点的子树的根结点称为这个结点的孩子（child）。

**双亲（Parent）结点：** 若树中某个结点有孩子结点，则这个结点称为它的孩子结点的双亲结点，双亲结点也称作直接前驱结点。

**兄弟（Sibling）结点：** 具有相同的双亲结点的结点称为兄弟结点（Sibling）。

**树的度（Degree）：** 树中所有结点的度的最大值称为该树的度（Degree）。

**结点的层次（Level）：**

**树的深度（Depth）：**

**路径（Path）：**

**有序树（Order Tree）：**

**无序树（Unordered Tree）**

**森林（Forest）**



#### 树形结构的逻辑特征

用树中结点的父子关系来描述：

- 树中任一结构都可以用零个或多个直接后继（即孩子）结点，但至多只能有一个直接前趋（即双亲）结点。
- 树中只有根结点五前趋，它是开始结点；叶子结点无后继，是终端结点。
- 祖先与孙子的关系是对父子关系的延申，定义了树中结点之间的纵向次序。
- 有序树中，同一组兄弟结点从左到右有长幼之分。对这一关系加以延申，规定若k1和k2是兄弟结点，且k1在k2的右边，则k1的任一子孙都在k2的任一子孙的左边，这样就定义了树中结点之间的横向次序。



### 1.2  树的表示方法

- 直观表示法
- 形式化表示法
- 凹入表示法
- 文氏表示法
- 广义表表示法



### 1.3  树的抽象数据类型

#### 1.3.1  数据集合

树的结点集合，每个结点由数据元素和构成元素之间关系的指针组成。

#### 1.3.2  操作集合

1. 初始化Initiate(T)：
2. 双亲结点Parent(T, curr)：若树T存在，则寻找树T中当前结点curr的双亲结点。若成功，则返回curr的双亲结点；否则返回空指针。
3. 第一个孩子结点LeftChild(T,curr)：若树T存在且当前结点curr存在，则寻找curr的第一个孩子结点（或称作最左孩子结点）。若成功，则返回curr的第一个孩子结点；否则返回空指针。
4. 下一个兄弟结点RightSibling(T, curr)：若树T存在且当前结点curr存在，则寻找curr的右兄弟结点指针（或称作右兄弟结点）。若成功，则返回curr的右兄弟结点；否则返回空指针。
5. 遍历树Traverse(T, Visit())：若树T存在，则按某种遍历方法访问树T的每个结点，且每个结点只访问依次。访问结点时，要实现的具体操作由函数Visit()完成。树的遍历方法主要由先根遍历方法、后根遍历方法和层序遍历方法三种。
6. 撤销树D二story Tree(T)：撤销树T占用的所有动态内存空间。
7. 查找：找到根结点、双亲结点、孩子结点、叶子结点、指定值的结点等。
8. 删除：在指定位置删除结点。
9. 插入：在指定位置插入结点。
10. 求深度：计算树的高度。



## 2.  树的存储结构

在计算机中存储树的信息，要求既要存储结点的数据元素，又要存储结点之间的逻辑关系信息。树的结点之间的逻辑关系主要有双亲--孩子关系、兄弟关系等。因此，从结点之间的逻辑关系分，树的存储结构主要有：双亲表示法、孩子表示法、双亲孩子表示法和孩子兄弟表示法4中组合。

> 树形结构存储结点间的联系的原则
>
> 特点：每个结点与其直接相连的结点的关系只有两类：一类是双亲，一类是孩子，对一个结点而言，其双亲只有一个，孩子可以有0到n个。树形结构的存储结构设计原则，就是要实现双亲、孩子关系如何直接或间接存储。只要在存储结构中能找到一个结点的这两种关系，那么这样的存储结构设计就是可行的。双亲孩子检验原则。

构造结点之间逻辑关系的方法是使用指针。指针有指向内存单元地址的指针和静态链表形式的指针。树的每种存储结构既可以用常规指针方法构造，也可以用仿真指针方法构造。





1. #####  双亲孩子表示法

   指针既表示出每个结点的双亲结点，也表示出每个结点的孩子结点。

   ```c
   typedef struct {
       datatype data;    // 数据域
       int parent;       // 栓亲位置
       int child[D]      // 孩子位置
   }PCtree
   ```

   

2. ##### 双亲表示法

   用指针表示出每个结点的双亲结点。每个结点应有两个域，一个是数据域，另一个是指示其双亲在数组中的下标的仿真指针域。

   双亲表示法对于树的操作集合中寻找一个结点的双亲结点操作实现很方便，但对于寻找一个结点的孩子结点操作实现却不方便。

   ```c
   typedef struct {
       datatype data;    // 数据域
       int parent;       // 栓亲位置
   }PCtree
   ```

   

3. ##### 孩子表示法

   指针表示出每个结点的孩子结点。树中每个结点的子树个数不一定相同，如果按每个结点的度设计长度不等的每个结点的孩子指针域，则算法实现非常麻烦。孩子表示法可按树的度设计结点的孩子指针域个数。

   ```c
   typedef struct {
       datatype data;    // 数据域
       int child[D]      // 孩子位置
   }PCtree
   ```

   ```
   //链式结点
   typedef struct{
       datatype data;
       struct node *next;
   }linklist;
   ```

   ```
   //数组结点
   typedef struct {
       datatype data;
       linklist *link;
   }Ltree;
   Ltree T[N];
   ```

   

4. ##### 孩子兄弟表示法

   既表示出每个结点的第一个孩子结点，也表示出每个结点的下一个兄弟结点。需要为每个结点设计出三个域：数据元素域，该节点的第一个孩子指针域，该结点的下一个兄弟指针域。

   在实际使用中，孩子兄弟表示法中的指针通常使用常规指针。每个结点最多只有两个指针域，并且这两个指针域含义不同，左边指针指向该结点的第一个孩子结点，右边指针指向该结点的下一个兄弟结点。所以，孩子兄弟表示法实际是把树存储为一种二叉树结构。

   ```
   typedef struct Node{
       datatype data;
       struct Node *leftChild;
       struct Node *rightChild;
   }BinTreeNode;
   ```

   



## 3.  二叉树的逻辑结构

### 3.1  二叉树的定义

二叉树是n（n>=0）个有限结点构成的集合。n=0的树称为空二叉树；n=1的树只有一个根节点；n>1的二叉树由一个根节点和至多两个互不相交、分别称作左子树和右子树的子二叉树构成。

二叉树中所有树的形态共有5种：空结点、无左右子树的结点、只有左子树的结点、只有右子树的结点和左右子树均存在的结点。

**满二叉树：** 在一颗二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上，则这样的二叉树称作满二叉树

**完全二叉树：** 如果一棵具有n个结点的二叉树的结构与满二叉树的前n个结点的结构相同，这样的二叉树称作完全二叉树。

满二叉树一定是完全二叉树。



### 3.2 二叉树的抽象数据类型

#### 3.2.1  数据集合

二叉树的结点集合，每个结点由元素和构成元素之间关系的指针组成。

#### 3.2.2  操作集合

1. 初始化Initiate(T)：初始化二叉树T
2. 左插入结点InsertLeftNode(curr, x)：若当前结点curr非空，在curr的左子树中插入元素x的新结点，则原curr的左子树称为新插入结点的左子树。
3. 右插入结点InsertRightNode(curr, x)：若当前结点curr非空，在curr的右子树中插入元素x的新结点，则原curr的右子树称为新插入结点的右子树。
4. 左删除子树DeleteLeftTree(curr)：若当前结点curr非空，则删除curr的左子树
5. 右删除子树DeleteRightTree(curr)：若当前结点curr非空，则删除curr的右子树。
6. 遍历二叉树Traverse(T, Visit())：若二叉树T存在，则按某种次序访问二叉树T的每个结点，且每个结点只访问一次。访问结束时，要实现的具体操作由函数Visit()完成。二叉树的遍历次序主要有先序遍历、中序遍历、后序遍历和层次遍历。
7. 撤销DedtroyTree(T)：撤销二叉树T。



#### 3.2.3  二叉树的性质

1. 
   $$
   若规定根结点的层数为0，则一棵非空二叉树的第i层上最多有2^i（i>=0）个结点。
   $$

2. 
   $$
   若规定只有根节点的二叉树的深度为0，则深度为k的二叉树的最大结点树是2^{k+1}-1(k>=-1)
   $$

3. 
   $$
   对于一棵非空的二叉树，如果叶子结点个数为n_0，度为2的结点数为n_2，则有n_0 = n_2 + 1
   $$
   











## 4.  二叉树的存储结构及实现









## 5.  树的遍历









